0.78u6
------

ソース全般の変更：
------------------

■メモリをさらに大幅変更。[Aaron Giles]

一番大きな変更はドライバのアドレスマップ宣言方法です。リード・ライトのアドレスマップを
別々に取るのではなく、マージしたマップ一つで済むようにしました。コードの変更を最小限
にするため、以前の分離アドレスマップもまだサポートしていますが、内部的にはメモリの初
期化とセットアップ時に一つにまとめられています。

この変更により、アドレスマップ用の“start”マクロも変更されました。以下の古いマクロセッ
ト：

   PROGRAM_READ*_MAP_START(name)
   DATA_READ*_MAP_START(name)
   IO_READ*_MAP_START(name)

は、次のマクロ一本に置き換えられました：

   ADDRESS_MAP_START(name, address_space, bits)

全ドライバで新しい方法を使うように更新されています。さらに、PROGRAM_*、DATA_*、IO_*な
どは全部ADRESS_*マクロにマージしました。たとえば、PROGRAM_MAP_FLAGSは
ADDRESS_MAP_FLAGSになってます。

もう一つの変更点はアドレスマップが統合されたことに加えて静的配列ではなくなったことで
す。マシンドライバとほとんど同じ方法で構成されるようになりました。アドレスマップはマ
クロ全般について、コード内で構成とタイプチェックされます。MAMEドライバ全部で新しいマ
クロへの更新がされています。

そのほかに、ミラーリングやポインタの自動割り当て、メモリポインタの共有などの新機能も
追加されています。このバージョンではとりあえずseattle.cとsystem24.cで、新型コンストラ
クタをサポートするように更新しました。このドライバを新機能のサンプルとして参考にして
ください。また、新マクロについての全解説はmemory.cの初めの部分に記載してあります。

メモリの自動割り当て方法もメモリマップベースに行われるように変更されていますが、前と
同様にメモリ領域の共有ポインタと、ハードコードポインタはサポートしています。

ステート保存も動作するはずですが、厳密に必要なデータ量よりも多くセーブされます。

内部的には、アドレスマップのルックアップテーブル方法が変更され、サブテーブルを再利用
できるようになりました。これは小さいメモリ領域が大きなアドレススペースでミラーリング
される場合に重要です。古いコードではサブテーブルと結び付きがなかったので、ミラーリン
グの扱いが大変でした。

OP_ROM、OP_RAMなどの内部メモリステートをリネームしました。

■64bitデータタイプのセーブステートをサポート。[Olivier Galibert]
